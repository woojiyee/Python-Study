# 다이나믹 프로그래밍 DP
# f(6)은 1을 뺀 f(5), (3으로 나누어 떨어지는 수니까) 3으로 나눈 f(2),(2로 나누어 떨어지는 수니까)2로 나눈 f(3)을 호출하여 비교
# -> 큰 문제 f(6)은 f(5),f(2),f(3)을 호출?하는 '최적 부분 구조' 이며
# f(3)은 f(4)에서도 1을 뺀 경우 호출되고, f(6)에서도 2로 나눈 경우 호출되어 한 문제(f(3)) '중복되는 부분 문제'를 만족
# => 다이나믹 프로그래밍으로 풀면 되는 문제

# 주어진 수가 10일 때
# 답: 3회 10 - (-1) -> 9 - (%3) -> 3 - (%3) -> 1
# 10 - (%2) -> 5 - (-1)*2 -> 3 - (%3) -> 1 : 연산 4회

# 3으로 나눈 나머지 1 몫 3
# 2로 나눈 나머지 0 몫 5 

# 리스트   1  2          3          4                              5                                       
# 최소 횟수 0 1(%2 *1회) 1(%3 * 1회) 2(%2 * 2회 or -1 *1회 + %3 *1회) 3(-1 *1회 + %2 *2회 or -1 *2회 + %3 *1회) 
# 6                  7                            8          9         10  11                   18
# 2(%3 *1회 + %2 *1회) 3(-1 *1회 + %3 *1회 + %2*1회) 3(%2 *3회) 2(%3 *2회) 3   4( -1 *2회 + %3 *2회) (%3 *1회 + %2 *2회 or %2 )
# 주어진 수가 2일 때
# 답: 1회 2 - (%2) -> 1
# 2 -(-1)*2 -> 1 연산 횟수 2회

# 알고리즘
'''
입력받은 수 n
1. n가 3의 배수인가? 3으로 나눈 몫을 인덱스로 가지는 리스트 값(연산횟수) + 1(3으로 한번 나눴으니까) 한 값이 해당 인덱스의 리스트 값으로 넣기
2. n가 2의 배수인가? 2로 나눈 몫을 "
3. min( 
    n를 3으로 나눈 나머지 만큼을 n에서 뺀 값을 인덱스로 갖는 리스트의 값 + n를 3으로 나눈 나머지(-1한 횟수),
    n를 2 "
=> Ai = min(Ai-1,Ai/2,Ai/3)
'''

# Nth - 몇번이나 고침
n = int(input())

# 인덱스가 1이 되는 연산의 최소 횟수(최적의 해)를 해당 인덱스의 값으로 가지는 리스트
dp = [0] * (n+1) #1은 인덱스 1의 자리 (dp[0]은 안 씀)


dp[1] = 0
if n >=2:
    dp[2] = 1
if n >= 3:
    dp[3] = 1

for i in range(4,n+1):
    # 6으로 나눈 나머지가 0이면 = 6의 배열이면
    if i % 6 == 0:
        dp[i] = min(dp[i//3]+1, dp[i//2] +1)
    elif i % 3 == 0:
        # 3을 나눈 연산 횟수와 -1을 해서 2의 배수 상태로 만든 후 2로 나눈 연산 횟수 중 최소값
        dp[i] = min(dp[i//3] + 1,dp[i - i%2] + (i%2))
    elif i % 2 == 0:
        dp[i] = min(dp[i//2] + 1,dp[i - i%3] + (i%3))
    else:
        dp[i] = min(dp[i - i%3] + (i%3),dp[i - i%2] + (i%2))

print(dp)
print(dp[n])

# 정답!! 

# 이코테 풀이 참고
x = int(input())

# 입력받을 수 있는 수만큼 배열 만들어놓기
d = [0] * (10**6)+1

# 다이나믹 프로그래밍 진행 (보텀업: 작은 문제(수열의 앞)부터 구해서 큰 문제 구하는 방식)
for i in range(2,x+1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] +1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i],d[i//2] +1)
    if i % 3 == 0:
        d[i] = min(d[i],d[i//3]+1)

print(d[x])

#? 런타임 에러 뜸

# 나는 경우에 따라 나누거 조건에 걸리면 elif로 안 내려가게 했는데
# 이코테는 그냥 모든 연산?을 다 하고 값을 바로 대입해서 첫 연산(-1)한 것과 다음 연산(나누기 2)한 것 중 작은 값을 다시 대입하게 하도록 함