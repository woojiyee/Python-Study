# 문제
'''
도현이 집 n개가 수직선 위에 존재
각 집의 좌표는 x1,...xn ( 각 집은 독립적인 좌표를 가짐)
집에 공유기 c개를 설치
한 집에는 공유기 한개만 설치 가능
가장 인접한 두 공유기 사이의 거리를 가능한 크게 설치하려고 함!'''

# 1st
'''
# 집 개수, 공유기 개수
n,c = map(int,input().split())
# 집 좌표
x= []
x.append(int(input()) for i in range(n))
'''
# 머를 이진탐색의 start,end,mid값으로 잡아야할지 모르겠음

# 2nd (블로그)
# 아이디어
'''
알고리즘에서 전제 사항?: 첫집에는 무조건 공유기를 설치하는 듯 (문제에서 주어진 건 아님)
공유기 사이의 거리를 start,end,mid 값으로 잡고 이진탐색을 통하여 mid값을 바꿔가며 원하는 공유기 사이 거리를 찾을거임
start = 입력받은 공유기 사이 거리의 최소값을 구하려면 각 집마다의 거리를 다 구해서 비교해야하니 그냥 1로 잡고 하는 듯..
( start = 1  )
end = 입력받은 공유기 사이 거리의 최대값
( 첫번째 집과 마즈막 집의 거리가 입력받은 집에 공유기를 설치할 때 최대 거리니까)
공유기가 설치된 전집에서 현재 집까지의 거리가 해당 mid값보다 크거나 같으면 현재 집에 공유기 설치
 ( -> 설치한 공유기 수 +1) + 여기서 전집에서 mid만큼의 거리 이상에 있는 집을 체킹할거기 때문에 거리 체킹을 위해 집 리스트는 정렬되어있어야함!!
- mid 이상의 거리인 집들에 공유기를 설치시, 설치한 공유기 수 > 문제에서 입력받은 공유기 수
  <=> 구해야하는 공유기간의 거리보다 mid가 더 작았기에(공유기간의 거리가 짧았기에) mid간격으로 설치한 공유기 수가 입력받은 공유기 수보다 많았던 것
  <=> 공유기간의 거리를 키워줘야함 -> start = mid+1
- mid 이상의 거리인 집들에 공유기를 설치시, 설치한 공유기 수 < 문제에서 입력받은 공유기 수
  <=> 구해야하는 공유기간의 거리보다 mid가 더 컸기에 mid 간격으로 설치한 공유기 수가 입력받은 공유기 수보다 작았던 것
  <=> 공유기간의 거리를 줄여줘야함 -> end = mid-1
  
  '''

# 집 수, 공유기 수
n, c = map(int,input().split())

home = [int(input()) for _ in range(n)]

# binary()에서 mid 거리 이상 간격의 집을 체킹 할거임
# 그러면 home이 일직선상에 순서대로 있어야 공유기 설치한 마즈막 집을 변수에 저장해서 그 집에서부터 mid거리 체킹이 가능
# 예 ) 
# home = [1,2,4,8],mid=2 
# 1에서 2이상인 집 4를 last 현재 공유기가 마즈막 설치된 집 <=> last = 4 그리고 그 다음 집이 last+mid = 6 이상인지 체크 ...
# 정렬안된 경우 home = [1,4,2,8],mid = 2
# 1에서 거리가 2 이상인 집 4 = last
# 4에서 거리가 2 이상인 집을 2 = last가 되버리면 1,2는 간격이 2 이상이 아님 -> 문제 발생!
# 한 방향(숫자가 작은 집에서 큰 집순을)으로 공유기 간격이 체크되면서 거리 조건에 맞는 집에 공유기가 설치되는 게 아닌
# 우측 방향으로 거리 조건을 체킹하다가 다시 역방향으로 거리 체킹을 하게 되면서 이전에 공유기 설치한 집과의 간격이 조건에 안 맞게 될 수가 있음!
home.sort()


# 공유기 최소 간격
start = 1
# 공유기 최대 간격
end = home[-1] - home[0]

answer = 0

while start <= end:
    mid = (start + end)//2

    # 첫집에 공유기 설치
    # 현재 공유기가 마즈막으로 설치된 집 = 첫집
    last = home[0]
    # 현재 mid 이상의 간격으로 공유기 설치시 설치된 공유기 수
    count = 1

    # 첫집엔 이미 공유기를 설치했으니 두번째 집부터 조건 확인하며 공유기 설치
    for i in range(1,n):
        # i번째 집이 공유기를 설치한 마지막 집에서 간격이 mid 이상 떨어져있다면
        if last+mid <= home[i]:
            last = home[i]
            count+=1

    # 최소 mid 간격으로 공유기를 설치했을 때 설치된 공유기 수 > 문제에서 주어진 공유기
    if count >= c:
        # 공유기간의 거리가 짧아서 설치된 공유기 수가 적은 것
        # -> 공유기간의 거리를 키워주기
        start = mid + 1
        answer = mid
    else:
        end = mid -1

print(answer)

