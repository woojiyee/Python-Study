# 문제
'''
- n 명의 사람들은 오민식의 지시한 순서대로 1줄로 선다
- 오민식은 줄 서는 위치를 기록해놓고 그 기록과 비교하여 사람들이 줄을 선 위치가 맞는지 확인한다.
- 사람들은 자기보다 큰 사람이 왼쪽에 몇명 있었는지만을 기억
- n명의 사람이 있고, 사람들의 키는 1부터 n까지 모두 다름

각 사람들이 기억하는 정보가 주어질 때, 줄을 어떻게 서야하는지 출력하는 프로그램을 작성

입력
사람수 n
키가 1인 사람부터 차례대로 자기보다 큰 사람이 왼쪽에 몇명 있었는지 주어진다

ex 1)
입)
4
2 1 1 0
키가 1인 애의 왼쪽 : 1보다 큰 애가 2명 ? ? 1 ?
키가 2인 애의 왼쪽 : 2보다 큰 애가 1명 ? 2 1 ?
키가 3인 애의 왼쪽 : 3보다 큰 애가 1명 ? 2 1 3
키가 4인 애의 왼쪽 : 4보다 큰 애가 0명 4 2 1 3
-> 선 순서: (키) 
   4는 왼쪽에 자신보다 큰 애가 0명, 근데 어딜 서도 젤 크니까 자기보다 작은애는 0명 ? 4 ? 
   3은 어느 위치에 서든 4 오른쪽에만 선다면 자기보다 큰 왼쪽에 있는 사람 수는 1명  ? 4 ? 3 ?
   2는 4가 젤 첫번째에 섰으니까 이미 자기보타 큰 왼쪽 사람수가 1명, 2의 왼쪽에 3이 있으면 안 됨 ? 4 ? 2 ? 3 ?
   1은 왼쪽에 자신보다 큰 애가 2명이니까 4 2 1 3

ex 4)
입)
7
6 1 1 1 2 0 0
키가 1인 애의 왼쪽 : 1보다 큰 애가 6명 ? ? ? ? ? ? 1
키가 2인 애의 왼쪽 : 2보다 큰 애가 1명 ? 2 ? ? ? ? 1
키가 3인 애의 왼쪽 : 3보다 큰 애가 1명 ? 2 3 ? ? ? 1
키가 4인 애의 왼쪽 : 4보다 큰 애가 1명 ? 2 3 4 ? ? 1
키가 5인 애의 왼쪽 : 5보다 큰 애가 2명 ? 2 3 4 ? 5 1
키가 6인 애의 왼쪽 : 6보다 큰 애가 0명 6 2 3 4 ? 5 1
키가 7인 애의 왼쪽 : 7보다 큰 애가 0명 6 2 3 4 7 5 1
'''

# 아이디어
'''
키가 작은 애부터 돌아갈 떄,
다음 애들은 다 해당 사람보다 큰 애들이므로 
해당 사람보다 큰 왼쪽의 사람 수(ex)키가 1인 경우: 6명)만큼의 빈자리를 두고 다음 자리가 해당 사람의 번째 수(7번째)
근데 이미 그 위치에 사람이 서있다면 바로 다음 위치가 본인의 위치
(ex)키가 3인 경우, 왼쪽 사람이 1명이라서 2번째 위치에 서야하나 이미 2번째 위치엔 사람이 서 있기에 다음 빈자리인 3번째가 키3의 위치)
'''

# 1st
'''
n = int(input())

location = [0] * n

left = list(map(int,input().split()))

for i in range(n):
    cnt = 0
    for j in range(n-1):
        if location[j] == 0:
            cnt += 1
        if cnt == left[i]:
            if location[j+1] == 0:
                location[j+1] = i+1
                break

print(*location)
'''
# 예제 1 출력값이 0213으로 나옴
# 문제점: 위 코드로 할 시, 빈자리가 0인 경우에 제대로 돌아가지 않음

# 2nd

n = int(input())

# 빈 자리: 0, 각 위치에 서는 키 번호? 넣는 리스트
location = [0] * n

# 입력받는 데이터
# 키가 1인 사람부터 차례대로 왼쪽에 서는 사람 중 자신보다 큰 사람 수
left = list(map(int,input().split()))

for i in range(n):
    # 해당 자리보다 왼쪽에 빈 자리수 체크
    cnt = 0
    for j in range(n):
        # j-1번째(j 앞까지의) 빈 자리수 == 키가 i인 사람의 왼쪽 큰 사람 수 
        if cnt == left[i]:
            # j번째가 빈 자리인가
            if location[j] == 0:
                # 빈 자리면 j번째에 키가 i+1인 사람 세우기
                # 키는 1부터 시작하는데 i는 0부터 시작하기에 i+1
                location[j] = i+1
                # 자리에 세웠으면 다음 자리들 체크 할 필요 없음
                # 다음 키의 사람 for문 돌리면 됨
                break
            # 빈 자리가 아니고 이미 다른이가 서있다면 다음 오른쪽 자리로 넘어가기
            # 이미 j번째가 빈자리가 아님을 아니까 굳이 아래 if문을 돌릴 필요가 없음
            continue
        # j 자리가 빈자리면 빈자리수 + 1
        if location[j] == 0:
            cnt += 1

print(*location)

# 2nd 백준 맞았습니다.

# 3rd (2nd에서 중복된 부분 수정)

n = int(input())

location = [0] * n

left = list(map(int,input().split()))

for i in range(n):
    cnt = 0
    for j in range(n):
        # 해당 자리가 빈 자리인지 먼저 체크
        if location[j] == 0:
            # 빈 자리이면서 
            # (해당 자리 앞자리까지의 빈자리수 = i번째 키의 왼쪽 사람수) 조건을 만족할 때
            # 해당 자리에 i번째 키 세우기
            # (키는 1부터 시작, but i는 0부터 시작 -> i+1)
            if cnt == left[i]:
                location[j] = i+1
                # 자리에 세웠으면 다음 자리들 체크 할 필요 없음
                # 다음 키의 사람 for문 돌리면 됨
                break
            # 빈 자리일 때 빈 자리수 +1
            cnt += 1

print(*location)

# 3rd 백준 맞았습니다.