# 이것이 코딩 테스트다.10장 그래프 이론

# 문제
'''
정수 a->b로 바꿀 때 필요한 연산의 최솟값은?
가능한 연산 
- 2를 곱한다
- 수의 가장 오른쪽에 1을 추가
출력
연산의 최솟값+1 ( 만들 수 없는 경우: -1)
'''
# 알고리즘
'''
a에 곱하기 2한 값, 뒤에 1 추가한 값 동시에 저장
-> 연산한 값이 b보다 크면 연산 진행 x
-> 연산한 값이 b보다 크지 않다면 계속 진행
=> 여기서 문제는 연산을 얼마나 해야할지도 모르기에 저장 공간(리스트 원소 수)를 어느 정도의 크기로 선언해야할지 모르겠음
   그리고 트리마냥 레벨(같은 층인 노드들)이 있고 같은 레벨이라면 연산횟수가 같은 건데 노드들의 레벨을 어떻게 구분해서 연산횟수를 같이 저장해야할지 모르겠음
'''

# 1st ( 블로그 안 보고 내가 품!)
# 아이디어
'''
a에서 시작하니 b 초과인 값들 다 체크해줘야 함 + 연산 결과가 너무 많음
-> b에서 a로 역으로 연산해볼까?
- 곱하기는 나누기를 해야하는 거니까 나눠지는 수만 나누는 거라 조건이 생겨서 별도의 조건 없는 곱하기보단 연산 경우의 수가 상대적으로 적음!
'''
a, b = map(int,input().split())

# 연산 횟수
cnt = 0

# a가 연산하여 b가 될 수 있는지 여부
check = True

def possibility(a,b):
    # 연산의 결과값
    num = b
    global cnt
    # check를 global 선언 안 해주면 
    # 아래서 check = False라고 값을 할당해줘서? 
    # 전역 변수가 아닌 지역 변수로 함수 내에서만 check값이 False가 되고 함수 밖은 변하지 않음
    global check
    # b가 연산 후의 값이 a와 같을 때까지 반복
    while num != a:
        # a보다 작아지면 안 됨
        if num < a:
            check = False
            break
        # 1의 자리수가 1이면
        # = 10으로 나눈 나머지가 1이면
        if num % 10 == 1:
            # 1의 자리수 떼주기
            # -> 10의 자리수까지만 남겨놓기 = 10으로 나눈 몫
            # (주의) 실수 나누기 하면 61일 때 10으로 나눈 몫이 6.1이 됨
            # 근데 여기선 1을 떼고 6만 원하니 정수 나누기로 해줘야함
            num = num//10
            # 연산 했으니 연산 횟수 1 증가
            cnt += 1
        # 2로 나누어 떨어지면
        # = 2로 나눈 나머지가 0이면
        elif num % 2 == 0:
            num = num/2
            # 연산 했으니 연산 횟수 1 증가
            cnt += 1
        # 더 이상 1의 자리수가 1이 아니고 2로도 나누어 떨어지지 않는다면 a가 b가 될 수 없는 것
        else:
            check = False
            break


possibility(a,b)

if check != False:
    print(cnt+1)
else:
    print(-1)

